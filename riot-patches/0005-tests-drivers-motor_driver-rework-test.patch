From 664d72939f7074d182ef599cb71a527088c98910 Mon Sep 17 00:00:00 2001
From: Gilles DOFFE <g.doffe@gmail.com>
Date: Mon, 14 Aug 2023 03:44:59 +0200
Subject: [PATCH 4/7] tests/drivers/motor_driver: rework test

Rework the test as the motor_driver module has been reworked to be
compliant ith RIOT device driver development guide.

Mainly keep same behavior and use a simpler callback to illustrate post
motor_set() callback use.

Signed-off-by: Gilles DOFFE <g.doffe@gmail.com>
---
 tests/drivers/motor_driver/Makefile   |  5 ++-
 tests/drivers/motor_driver/init_dev.h | 51 +++++++++++++++++++++++++++
 tests/drivers/motor_driver/main.c     | 45 ++++++++++++++++-------
 3 files changed, 85 insertions(+), 16 deletions(-)
 create mode 100644 tests/drivers/motor_driver/init_dev.h

diff --git a/tests/drivers/motor_driver/Makefile b/tests/drivers/motor_driver/Makefile
index ae186a3e58..468cf0ff9f 100644
--- a/tests/drivers/motor_driver/Makefile
+++ b/tests/drivers/motor_driver/Makefile
@@ -1,14 +1,13 @@
 BOARD ?= native
 
+INCLUDES += -I$(APPDIR)
+
 include ../Makefile.drivers_common
 
 USEMODULE += motor_driver
 USEMODULE += shell_cmds_default
 USEMODULE += xtimer
 
-FEATURES_REQUIRED += periph_qdec
-FEATURES_REQUIRED += motor_driver
-
 CFLAGS += -DLOG_LEVEL=LOG_DEBUG
 CFLAGS += -DDEBUG_ASSERT_VERBOSE
 
diff --git a/tests/drivers/motor_driver/init_dev.h b/tests/drivers/motor_driver/init_dev.h
new file mode 100644
index 0000000000..19cecafccb
--- /dev/null
+++ b/tests/drivers/motor_driver/init_dev.h
@@ -0,0 +1,51 @@
+ /*
+ * Copyright (C) 2023 COGIP Robotics association
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       Motor driver test header file.
+ *
+ * @author      Gilles DOFFE <g.doffe@gmail.com>
+ *
+ */
+
+#ifndef INIT_DEV_H
+#define INIT_DEV_H
+
+#include <motor_driver.h>
+
+#ifndef MOTOR_DRIVER_PARAM_MOTOR_SET_POST_CALLBACK
+/** Default callback called at end of motor_set() */
+#define MOTOR_DRIVER_PARAM_MOTOR_SET_POST_CALLBACK  motor_driver_callback_example
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Simple motor_set post callback example.
+ * Just print current PWM value.
+ *
+ * @param[in] motor_driver      motor driver to which motor is attached
+ * @param[in] motor_id          motor ID on driver
+ * @param[in] pwm_duty_cycle    Signed PWM duty_cycle to set motor speed and direction
+ */
+void motor_driver_callback_example(
+    const motor_driver_t *motor_driver, uint8_t motor_id,
+    int32_t pwm_duty_cycle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* INIT_DEV_H */
+/** @} */
diff --git a/tests/drivers/motor_driver/main.c b/tests/drivers/motor_driver/main.c
index 5f47bd97bd..a35a390f6e 100644
--- a/tests/drivers/motor_driver/main.c
+++ b/tests/drivers/motor_driver/main.c
@@ -21,20 +21,36 @@
 #include <string.h>
 
 /* RIOT includes */
+#include "init_dev.h"
 #include "log.h"
 #include "motor_driver.h"
+#include "motor_driver_params.h"
 #include "test_utils/expect.h"
 #include "xtimer.h"
 
+
+void motor_driver_callback_example(
+    const motor_driver_t *motor_driver, uint8_t motor_id,
+    int32_t pwm_duty_cycle)
+{
+    LOG_DEBUG("MOTOR-DRIVER=%p" \
+        "    MOTOR_ID = %u"     \
+        "    PWM_VALUE = %d\n", \
+        (void*)motor_driver, motor_id,
+        pwm_duty_cycle);
+}
+
 /* set interval to 20 milli-second */
 #define INTERVAL (3000 * US_PER_MS)
 
 #define MOTOR_0_ID  0
 #define MOTOR_1_ID  1
 
+static motor_driver_t motor_driver;
+
 void motors_control(int32_t duty_cycle)
 {
-    char str[6];
+    char str[4];
 
     if (duty_cycle >= 0) {
         strncpy(str, "CW", 3);
@@ -43,13 +59,13 @@ void motors_control(int32_t duty_cycle)
         strncpy(str, "CCW", 4);
     }
 
-    printf("Duty cycle = %" PRId32 "   Direction = %s\n", duty_cycle, str);
+    puts("\nActuate Motors");
 
-    if (motor_set(MOTOR_DRIVER_DEV(0), MOTOR_0_ID, duty_cycle)) {
+    if (motor_set(&motor_driver, MOTOR_0_ID, duty_cycle)) {
         printf("Cannot set PWM duty cycle for motor %" PRIu32 "\n", \
                (uint32_t)MOTOR_0_ID);
     }
-    if (motor_set(MOTOR_DRIVER_DEV(0), MOTOR_1_ID, duty_cycle)) {
+    if (motor_set(&motor_driver, MOTOR_1_ID, duty_cycle)) {
         printf("Cannot set PWM duty cycle for motor %" PRIu32 "\n", \
                (uint32_t)MOTOR_1_ID);
     }
@@ -57,12 +73,12 @@ void motors_control(int32_t duty_cycle)
 
 void motors_brake(void)
 {
-    puts("Brake motors !!!");
+    puts("\nBrake motors");
 
-    if (motor_brake(MOTOR_DRIVER_DEV(0), MOTOR_0_ID)) {
+    if (motor_brake(&motor_driver, MOTOR_0_ID)) {
         printf("Cannot brake motor %" PRIu32 "\n", (uint32_t)MOTOR_0_ID);
     }
-    if (motor_brake(MOTOR_DRIVER_DEV(0), MOTOR_1_ID)) {
+    if (motor_brake(&motor_driver, MOTOR_1_ID)) {
         printf("Cannot brake motor %" PRIu32 "\n", (uint32_t)MOTOR_1_ID);
     }
 }
@@ -72,9 +88,9 @@ void motion_control(void)
     int8_t dir = 1;
     int ret = 0;
     xtimer_ticks32_t last_wakeup /*, start*/;
-    int32_t pwm_res = motor_driver_config[MOTOR_DRIVER_DEV(0)].pwm_resolution;
+    int32_t pwm_res = motor_driver_params->pwm_resolution;
 
-    ret = motor_driver_init(MOTOR_DRIVER_DEV(0));
+    ret = motor_driver_init(&motor_driver, &motor_driver_params[0]);
     if (ret) {
         LOG_ERROR("motor_driver_init failed with error code %d\n", ret);
     }
@@ -94,11 +110,14 @@ void motion_control(void)
         /* Disable motor during INTERVAL Âµs (motor driver must have enable
            feature */
         last_wakeup = xtimer_now();
-        motor_disable(MOTOR_DRIVER_DEV(0), MOTOR_0_ID);
-        motor_disable(MOTOR_DRIVER_DEV(0), MOTOR_1_ID);
+        puts("\nDisable motors");
+        motor_disable(&motor_driver, MOTOR_0_ID);
+        motor_disable(&motor_driver, MOTOR_1_ID);
+        xtimer_periodic_wakeup(&last_wakeup, INTERVAL);
+        puts("\nEnable motors");
+        motor_enable(&motor_driver, MOTOR_0_ID);
+        motor_enable(&motor_driver, MOTOR_1_ID);
         xtimer_periodic_wakeup(&last_wakeup, INTERVAL);
-        motor_enable(MOTOR_DRIVER_DEV(0), MOTOR_0_ID);
-        motor_enable(MOTOR_DRIVER_DEV(0), MOTOR_1_ID);
 
         /* CW - duty cycle 100% */
         last_wakeup = xtimer_now();
-- 
2.37.0

