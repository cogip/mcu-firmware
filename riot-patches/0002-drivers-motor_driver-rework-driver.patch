From 194eb9d8f1a33e20cb23911b1d3091aa706c08de Mon Sep 17 00:00:00 2001
From: Gilles DOFFE <g.doffe@gmail.com>
Date: Thu, 3 Aug 2023 02:03:34 +0200
Subject: [PATCH 1/7] drivers/motor_driver: rework driver

The motor_driver device driver is developped as a periph driver and it
should not.
Make this driver compliant with RIOT device driver development guide
[1].
Also make some cleanups and fix some typos.

[1] https://doc.riot-os.org/driver-guide.html

Signed-off-by: Gilles DOFFE <g.doffe@gmail.com>
---
 drivers/include/motor_driver.h                | 114 +++---
 drivers/motor_driver/Makefile.include         |   2 +
 .../include/motor_driver_params.h             | 177 +++++++++
 drivers/motor_driver/motor_driver.c           | 361 +++++++++---------
 4 files changed, 433 insertions(+), 221 deletions(-)
 create mode 100644 drivers/motor_driver/Makefile.include
 create mode 100644 drivers/motor_driver/include/motor_driver_params.h

diff --git a/drivers/include/motor_driver.h b/drivers/include/motor_driver.h
index 38a1326b58..275fc3d239 100644
--- a/drivers/include/motor_driver.h
+++ b/drivers/include/motor_driver.h
@@ -7,7 +7,7 @@
  */
 
 /**
- * @defgroup    drivers_motor DC Motor Driver
+ * @defgroup    drivers_motor_driver DC Motor Driver
  * @ingroup     drivers_actuators
  * @brief       High-level driver for DC motors
  *
@@ -71,8 +71,9 @@
  *
  * BRAKE LOW is functionally the same than BRAKE HIGH but some H-bridge only
  * brake on BRAKE HIGH due to hardware.
- * In case of single direction GPIO, there is no BRAKE, PWM duty cycle is set
- * to 0.
+ * In case of single direction GPIO, there is no BRAKE.
+ *
+ * In case of brake, PWM duty cycle is always set to 0.
 
  * @{
  * @file
@@ -92,7 +93,7 @@ extern "C" {
 #endif
 
 /**
- * @defgroup drivers_motor_driver_config     Motor_Driver driver compile configuration
+ * @defgroup drivers_motor_driver_config     motor_driver driver build configuration
  * @ingroup config_drivers_actuators
  * @{
  */
@@ -105,29 +106,32 @@ extern "C" {
 /** @} */
 
 /**
- * @brief Macro to return motor driver id
+ * @brief Describe DC motor driver modes
  */
-#define MOTOR_DRIVER_DEV(x) (x)
+typedef enum {
+    MOTOR_DRIVER_2_DIRS         = 0,            /**< 2 GPIOs for direction, \
+                                                     handling brake */
+    MOTOR_DRIVER_1_DIR          = 1,            /**< single GPIO for direction, \
+                                                     no brake */
+    MOTOR_DRIVER_1_DIR_BRAKE    = 2             /**< single GPIO for direction, \
+                                                     single GPIO for brake */
+} motor_driver_mode_t;
 
 /**
- * @brief Describe DC motor driver modes
+ * @brief Describe DC motor driver brake levels
  */
 typedef enum {
-    MOTOR_DRIVER_2_DIRS         = 0,            /**< 2 GPIOS for direction, \
-                                                      handling BRAKE */
-    MOTOR_DRIVER_1_DIR          = 1,            /**< Single GPIO for direction, \
-                                                      no BRAKE */
-    MOTOR_DRIVER_1_DIR_BRAKE    = 2             /**< Single GPIO for direction, \
-                                                      Single GPIO for BRAKE */
-} motor_driver_mode_t;
+    MOTOR_BRAKE_LOW     = 0,        /**< low level brake */
+    MOTOR_BRAKE_HIGH    = 1,        /**< high level brake */
+} motor_driver_brake_level_t;
 
 /**
- * @brief Describe DC motor driver brake modes
+ * @brief Describe DC motor driver enable levels
  */
 typedef enum {
-    MOTOR_BRAKE_LOW     = 0,        /**< Low stage brake */
-    MOTOR_BRAKE_HIGH    = 1,        /**< High stage brake */
-} motor_driver_mode_brake_t;
+    MOTOR_ENABLE_LOW     = 0,        /**< low level enable */
+    MOTOR_ENABLE_HIGH    = 1,        /**< high level enable */
+} motor_driver_enable_level_t;
 
 /**
  * @brief Describe DC motor direction states
@@ -146,58 +150,80 @@ typedef struct {
     gpio_t gpio_dir0;           /**< GPIO to control rotation direction */
     gpio_t gpio_dir1_or_brake;  /**< GPIO to control rotation direction */
     uint8_t gpio_dir_reverse;   /**< flag to reverse direction */
-    uint8_t gpio_enable_invert; /**< flag to set enable GPIO inverted mode */
-    uint8_t gpio_brake_invert;  /**< flag to make brake active low */
 } motor_t;
 
 /**
- * @brief   Default motor driver type definition
+ * @brief   Motor driver
  */
-typedef unsigned int motor_driver_t;
+typedef struct _motor_driver_t motor_driver_t;
 
 /**
  * @brief   Motor callback. It is called at end of motor_set()
  */
-typedef void (*motor_driver_cb_t)(const motor_driver_t motor_driver,
+typedef void (*motor_set_post_cb_t)(const motor_driver_t *motor_driver,
                                   uint8_t motor_id,
                                   int32_t pwm_duty_cycle);
 
+/**
+ * @brief   Motor set callback. Called to set motor speed.
+ */
+typedef void (*motor_set_cb_t)(const motor_t *motor,
+                               motor_direction_t direction);
+
+/**
+ * @brief   Motor brake callback. Called to brake a motor.
+ */
+typedef void (*motor_brake_cb_t)(const motor_t *motor,
+                                 motor_driver_brake_level_t brake);
+
 /**
  * @brief Describe DC motor driver with PWM device and motors array
  */
 typedef struct {
-    pwm_t pwm_dev;                          /**< PWM device driving motors */
-    motor_driver_mode_t mode;               /**< driver mode */
-    motor_driver_mode_brake_t mode_brake;   /**< driver brake mode */
-    pwm_mode_t pwm_mode;                    /**< PWM mode */
-    uint32_t pwm_frequency;                 /**< PWM device frequency */
-    uint32_t pwm_resolution;                /**< PWM device resolution */
-    uint8_t nb_motors;                      /**< number of moros */
-    motor_t motors[CONFIG_MOTOR_DRIVER_MAX];       /**< motors array */
-    motor_driver_cb_t cb;                   /**< callback on motor_set */
-} motor_driver_config_t;
+    motor_driver_mode_t mode;                   /**< driver mode */
+    pwm_t pwm_dev;                              /**< PWM device driving motors */
+    pwm_mode_t pwm_mode;                        /**< PWM mode */
+    uint32_t pwm_frequency;                     /**< PWM device frequency */
+    uint32_t pwm_resolution;                    /**< PWM device resolution */
+    motor_driver_brake_level_t brake_level;     /**< driver brake mode */
+    motor_driver_enable_level_t enable_level;   /**< driver brake mode */
+    uint8_t nb_motors;                          /**< number of motors */
+    motor_t motors[CONFIG_MOTOR_DRIVER_MAX];    /**< motors array */
+    motor_set_post_cb_t motor_set_post_cb;      /**< callback post to motor_set */
+} motor_driver_params_t;
+
+/**
+ * @brief   Motor driver
+ */
+struct _motor_driver_t {
+    const motor_driver_params_t *params;        /**< parameters */
+    motor_set_cb_t motor_set_cb;                /**< callback used by motor_set() to set direction */
+    motor_brake_cb_t motor_brake_cb;            /**< callback used by motor_brake() */
+};
 
 /**
  * @brief Initialize DC motor driver board
  *
- * @param[out] motor_driver     motor driver to initialize
+ * @param[out]  motor_driver        motor driver to initialize
+ * @param[in]   motor_driver_params motor driver parameters
  *
- * @return                      0 on success
- * @return                      -1 on error with errno set
+ * @return                          0 on success
+ * @return                          -EINVAL on bad parameter value
+ * @return                          -EIO on failed GPIO init
  */
-int motor_driver_init(const motor_driver_t motor_driver);
+int motor_driver_init(motor_driver_t *motor_driver, const motor_driver_params_t *motor_driver_params);
 
 /**
  * @brief Set motor speed and direction
  *
  * @param[in] motor_driver      motor driver to which motor is attached
  * @param[in] motor_id          motor ID on driver
- * @param[in] pwm_duty_cycle    Signed PWM duty_cycle to set motor speed and direction
+ * @param[in] pwm_duty_cycle    signed PWM duty_cycle to set motor speed and direction
  *
  * @return                      0 on success
- * @return                      -1 on error with errno set
+ * @return                      -EINVAL on bad motor ID
  */
-int motor_set(const motor_driver_t motor_driver, uint8_t motor_id, \
+int motor_set(const motor_driver_t *motor_driver, uint8_t motor_id, \
               int32_t pwm_duty_cycle);
 
 /**
@@ -207,9 +233,9 @@ int motor_set(const motor_driver_t motor_driver, uint8_t motor_id, \
  * @param[in] motor_id          motor ID on driver
  *
  * @return                      0 on success
- * @return                      -1 on error with errno set
+ * @return                      -EINVAL on bad motor ID
  */
-int motor_brake(const motor_driver_t motor_driver, uint8_t motor_id);
+int motor_brake(const motor_driver_t *motor_driver, uint8_t motor_id);
 
 /**
  * @brief Enable a motor of a given motor driver
@@ -219,7 +245,7 @@ int motor_brake(const motor_driver_t motor_driver, uint8_t motor_id);
  *
  * @return
  */
-void motor_enable(const motor_driver_t motor_driver, uint8_t motor_id);
+void motor_enable(const motor_driver_t *motor_driver, uint8_t motor_id);
 
 /**
  * @brief Disable a motor of a given motor driver
@@ -229,7 +255,7 @@ void motor_enable(const motor_driver_t motor_driver, uint8_t motor_id);
  *
  * @return
  */
-void motor_disable(const motor_driver_t motor_driver, uint8_t motor_id);
+void motor_disable(const motor_driver_t *motor_driver, uint8_t motor_id);
 
 #ifdef __cplusplus
 }
diff --git a/drivers/motor_driver/Makefile.include b/drivers/motor_driver/Makefile.include
new file mode 100644
index 0000000000..40d3127958
--- /dev/null
+++ b/drivers/motor_driver/Makefile.include
@@ -0,0 +1,2 @@
+USEMODULE_INCLUDES_motor_driver := $(LAST_MAKEFILEDIR)/include
+USEMODULE_INCLUDES += $(USEMODULE_INCLUDES_motor_driver)
diff --git a/drivers/motor_driver/include/motor_driver_params.h b/drivers/motor_driver/include/motor_driver_params.h
new file mode 100644
index 0000000000..d1959218af
--- /dev/null
+++ b/drivers/motor_driver/include/motor_driver_params.h
@@ -0,0 +1,177 @@
+ /*
+ * Copyright (C) 2023 COGIP Robotics association
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     drivers_motor_driver
+ * @{
+ *
+ * @file
+ * @brief       Default configuration for motor driver.
+ *
+ * @author      Gilles DOFFE <g.doffe@gmail.com>
+ *
+ */
+
+#ifndef MOTOR_DRIVER_PARAMS_H
+#define MOTOR_DRIVER_PARAMS_H
+
+#include "board.h"
+#include "motor_driver.h"
+#include "saul_reg.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name    Set default configuration parameters for motor_driver
+ * @{
+ */
+
+#ifndef MOTOR_DRIVER_PARAM_MODE
+/** Default motor driver mode */
+#define MOTOR_DRIVER_PARAM_MODE             MOTOR_DRIVER_1_DIR
+#endif
+#ifndef MOTOR_DRIVER_PARAM_BRAKE_LEVEL
+/** Default brake level */
+#define MOTOR_DRIVER_PARAM_BRAKE_LEVEL      MOTOR_BRAKE_LOW
+#endif
+#ifndef MOTOR_DRIVER_PARAM_ENABLE_LEVEL
+/** Default enable level */
+#define MOTOR_DRIVER_PARAM_ENABLE_LEVEL     MOTOR_ENABLE_LOW
+#endif
+#ifndef MOTOR_DRIVER_PARAM_PWM
+/** Default PWM device */
+#define MOTOR_DRIVER_PARAM_PWM              1
+#endif
+#ifndef MOTOR_DRIVER_PARAM_PWM_MODE
+/** Default PWM mode */
+#define MOTOR_DRIVER_PARAM_PWM_MODE         PWM_LEFT
+#endif
+#ifndef MOTOR_DRIVER_PARAM_PWM_FREQUENCY
+/** Default PWM frequency */
+#define MOTOR_DRIVER_PARAM_PWM_FREQUENCY    20000U
+#endif
+#ifndef MOTOR_DRIVER_PARAM_PWM_RESOLUTION
+/** Default PWM resolution */
+#define MOTOR_DRIVER_PARAM_PWM_RESOLUTION   100U
+#endif
+#ifndef MOTOR_DRIVER_PARAM_NB_MOTORS
+/** Default number of motors */
+#define MOTOR_DRIVER_PARAM_NB_MOTORS        2U
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR_SET_POST_CALLBACK
+/** Default callback called at end of motor_set() */
+#define MOTOR_DRIVER_PARAM_MOTOR_SET_POST_CALLBACK  NULL
+#endif
+
+/* Motor 1 */
+#ifndef MOTOR_DRIVER_PARAM_MOTOR1_PWM_CHANNEL
+/** Default motor 1 PWM channel */
+#define MOTOR_DRIVER_PARAM_MOTOR1_PWM_CHANNEL           1U
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR1_GPIO_ENABLE
+/** Default motor 1 enable GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR1_GPIO_ENABLE           GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR0
+/** Default motor 1 direction GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR0             GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR1_OR_BRAKE
+/** Default motor 1 direction or brake GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR1_OR_BRAKE    GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR_REVERSE
+/** Default motor 1 direction GPIO(s) reverse */
+#define MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR_REVERSE      0
+#endif
+
+/* Motor 2 */
+#ifndef MOTOR_DRIVER_PARAM_MOTOR2_PWM_CHANNEL
+/** Default motor 2 PWM channel */
+#define MOTOR_DRIVER_PARAM_MOTOR2_PWM_CHANNEL           2U
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR2_GPIO_ENABLE
+/** Default motor 2 enable GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR2_GPIO_ENABLE           GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR0
+/** Default motor 2 direction GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR0             GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR1_OR_BRAKE
+/** Default motor 2 direction or brake GPIO */
+#define MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR1_OR_BRAKE    GPIO_UNDEF
+#endif
+#ifndef MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR_REVERSE
+/** Default motor 2 direction GPIO(s) reverse */
+#define MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR_REVERSE      0
+#endif
+
+#ifndef MOTOR_DRIVER_PARAMS
+/** Default motor driver parameters */
+#define MOTOR_DRIVER_PARAMS \
+    { \
+        .mode            = MOTOR_DRIVER_PARAM_MODE, \
+        .pwm_dev         = MOTOR_DRIVER_PARAM_PWM, \
+        .pwm_mode        = MOTOR_DRIVER_PARAM_PWM_MODE, \
+        .pwm_frequency   = MOTOR_DRIVER_PARAM_PWM_FREQUENCY, \
+        .pwm_resolution  = MOTOR_DRIVER_PARAM_PWM_RESOLUTION, \
+        .brake_level     = MOTOR_DRIVER_PARAM_BRAKE_LEVEL, \
+        .enable_level    = MOTOR_DRIVER_PARAM_ENABLE_LEVEL, \
+        .nb_motors       = MOTOR_DRIVER_PARAM_NB_MOTORS, \
+        .motors          = { \
+            { \
+                .pwm_channel            = MOTOR_DRIVER_PARAM_MOTOR1_PWM_CHANNEL, \
+                .gpio_enable            = MOTOR_DRIVER_PARAM_MOTOR1_GPIO_ENABLE, \
+                .gpio_dir0              = MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR0, \
+                .gpio_dir1_or_brake     = MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR1_OR_BRAKE, \
+                .gpio_dir_reverse       = MOTOR_DRIVER_PARAM_MOTOR1_GPIO_DIR_REVERSE, \
+            }, \
+            { \
+                .pwm_channel            = MOTOR_DRIVER_PARAM_MOTOR2_PWM_CHANNEL, \
+                .gpio_enable            = MOTOR_DRIVER_PARAM_MOTOR2_GPIO_ENABLE, \
+                .gpio_dir0              = MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR0, \
+                .gpio_dir1_or_brake     = MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR1_OR_BRAKE, \
+                .gpio_dir_reverse       = MOTOR_DRIVER_PARAM_MOTOR2_GPIO_DIR_REVERSE, \
+            } \
+        }, \
+        .motor_set_post_cb = MOTOR_DRIVER_PARAM_MOTOR_SET_POST_CALLBACK \
+    }
+#endif
+
+/* SAUL */
+#ifndef MOTOR_DRIVER_SAUL_INFO
+/** SAUL information */
+#define MOTOR_DRIVER_SAUL_INFO         { .name = "motor_driver" }
+#endif
+/**@}*/
+
+/**
+ * @brief   MOTOR_DRIVER configuration
+ */
+static const motor_driver_params_t motor_driver_params[] =
+{
+    MOTOR_DRIVER_PARAMS,
+};
+
+/**
+ * @brief   Additional meta information to keep in the SAUL registry
+ */
+static const saul_reg_info_t motor_driver_saul_info[] =
+{
+    MOTOR_DRIVER_SAUL_INFO
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MOTOR_DRIVER_PARAMS_H */
+/** @} */
diff --git a/drivers/motor_driver/motor_driver.c b/drivers/motor_driver/motor_driver.c
index 3b837d33f6..2198858a2a 100644
--- a/drivers/motor_driver/motor_driver.c
+++ b/drivers/motor_driver/motor_driver.c
@@ -7,7 +7,7 @@
  */
 
 /**
- * @ingroup     drivers_motor
+ * @ingroup     drivers_motor_driver
  * @{
  *
  * @file
@@ -29,155 +29,169 @@
 #define ENABLE_DEBUG 0
 #include <debug.h>
 
-int motor_driver_init(motor_driver_t motor_driver)
-{
-    int err = 0;
+/**
+ * @brief Callback to set direction on two directions pins driver
+ *
+ * @param   motor       motor
+ * @param   direction   direction
+ */
+static void _motor_set_two_dirs(const motor_t *motor, motor_direction_t direction);
+
+/**
+ * @brief Callback to set direction on one direction pin driver
+ *
+ * @param   motor       motor
+ * @param   direction   direction
+ */
 
-    assert(motor_driver < MOTOR_DRIVER_NUMOF);
+static void _motor_set_one_dir(const motor_t *motor, motor_direction_t direction);
 
-    const motor_driver_config_t *motor_driver_conf = \
-        &motor_driver_config[motor_driver];
+static void _motor_brake_two_dirs(const motor_t *motor, motor_driver_brake_level_t brake);
+static void _motor_brake_one_dir_brake(const motor_t *motor, motor_driver_brake_level_t brake);
 
-    pwm_t pwm_dev = motor_driver_conf->pwm_dev;
-    pwm_mode_t mode = motor_driver_conf->pwm_mode;
-    uint32_t freq = motor_driver_conf->pwm_frequency;
-    uint16_t resol = motor_driver_conf->pwm_resolution;
+int motor_driver_init(motor_driver_t *motor_driver, const motor_driver_params_t *motor_driver_params)
+{
+    int err = 0;
 
-    uint32_t ret_pwm = pwm_init(pwm_dev, mode, freq, resol);
-    if (ret_pwm != freq) {
+    uint32_t ret_pwm = pwm_init(motor_driver_params->pwm_dev,
+                                motor_driver_params->pwm_mode,
+                                motor_driver_params->pwm_frequency,
+                                motor_driver_params->pwm_resolution);
+    if (ret_pwm != motor_driver_params->pwm_frequency) {
         err = EINVAL;
         LOG_ERROR("pwm_init failed\n");
         goto motor_init_err;
     }
 
-    for (uint8_t i = 0; i < motor_driver_conf->nb_motors; i++) {
-        if (gpio_is_valid(motor_driver_conf->motors[i].gpio_dir0)
-            && (gpio_init(motor_driver_conf->motors[i].gpio_dir0,
-                          GPIO_OUT))) {
-            err = EIO;
-            LOG_ERROR("gpio_dir0 init failed\n");
-            goto motor_init_err;
+    /* Init GPIO */
+    err = 0;
+    for (uint8_t i = 0; i < motor_driver_params->nb_motors; i++) {
+        /* Init motor GPIOs, if one fails, motor is not setup */
+        if (gpio_is_valid(motor_driver_params->motors[i].gpio_dir0)) {
+            if (gpio_init(motor_driver_params->motors[i].gpio_dir0,
+                          GPIO_OUT)) {
+                err = EIO;
+                LOG_ERROR("gpio_dir0 init failed for motor %d\n", i);
+                goto motor_init_err;
+            }
         }
-        if (gpio_is_valid(motor_driver_conf->motors[i].gpio_dir1_or_brake)
-            && (gpio_init(motor_driver_conf->motors[i].gpio_dir1_or_brake,
-                          GPIO_OUT))) {
-            err = EIO;
-            LOG_ERROR("gpio_dir1_or_brake init failed\n");
-            goto motor_init_err;
+        if (gpio_is_valid(motor_driver_params->motors[i].gpio_dir1_or_brake)) {
+            if (gpio_init(motor_driver_params->motors[i].gpio_dir1_or_brake,
+                          GPIO_OUT)) {
+                err = EIO;
+                LOG_ERROR("gpio_dir1_or_brake init failed for motor %d\n", i);
+                goto motor_init_err;
+            }
         }
-        if (gpio_is_valid(motor_driver_conf->motors[i].gpio_enable)) {
-            if (gpio_init(motor_driver_conf->motors[i].gpio_enable,
+        if (gpio_is_valid(motor_driver_params->motors[i].gpio_enable)) {
+            if (gpio_init(motor_driver_params->motors[i].gpio_enable,
                           GPIO_OUT)) {
                 err = EIO;
-                LOG_ERROR("gpio_enable init failed\n");
+                LOG_ERROR("gpio_enable init failed for motor %d\n", i);
                 goto motor_init_err;
             }
-            motor_enable(motor_driver, i);
         }
     }
 
-    return 0;
+    /* Set callbacks according to driver type */
+    switch(motor_driver_params->mode) {
+        /* Two direction GPIO, handling brake */
+        case MOTOR_DRIVER_2_DIRS:
+        motor_driver->motor_set_cb = _motor_set_two_dirs;
+        motor_driver->motor_brake_cb = _motor_brake_two_dirs;
+        break;
+        /* Single direction GPIO */
+        case MOTOR_DRIVER_1_DIR:
+        motor_driver->motor_set_cb = _motor_set_one_dir;
+        motor_driver->motor_set_cb = NULL;
+        break;
+        /* Single direction GPIO and brake GPIO */
+        case MOTOR_DRIVER_1_DIR_BRAKE:
+        motor_driver->motor_set_cb = _motor_set_one_dir;
+        motor_driver->motor_brake_cb = _motor_brake_one_dir_brake;
+        break;
+        /* Error */
+        default:
+            err = EINVAL;
+            goto motor_init_err;
+            break;
+    };
+
+    motor_driver->params = motor_driver_params;
 
 motor_init_err:
     return -err;
 }
 
-int motor_set(const motor_driver_t motor_driver, uint8_t motor_id, \
-              int32_t pwm_duty_cycle)
+static void _motor_set_two_dirs(const motor_t *motor, motor_direction_t direction)
 {
-    int err = 0;
-
-    assert(motor_driver < MOTOR_DRIVER_NUMOF);
+    if ((gpio_is_valid(motor->gpio_dir0))
+       && (gpio_is_valid(motor->gpio_dir1_or_brake))) {
+        gpio_write(motor->gpio_dir0, direction);
+        gpio_write(motor->gpio_dir1_or_brake, direction ^ 0x1);
+    }
+}
 
-    const motor_driver_config_t *motor_driver_conf =
-        &motor_driver_config[motor_driver];
+static void _motor_set_one_dir(const motor_t *motor, motor_direction_t direction)
+{
+    if (gpio_is_valid(motor->gpio_dir0)) {
+        gpio_write(motor->gpio_dir0, direction);
+    }
+}
 
-    assert(motor_id < motor_driver_conf->nb_motors);
+int motor_set(const motor_driver_t *motor_driver, uint8_t motor_id, \
+              int32_t pwm_duty_cycle)
+{
+    int err = 0;
 
-    const motor_t *dev = &motor_driver_conf->motors[motor_id];
+    if (motor_id >= motor_driver->params->nb_motors) {
+        err = EINVAL;
+        LOG_ERROR("Motor ID %u greater than number of motors %u\n",
+                  motor_id, motor_driver->params->nb_motors);
+        goto motor_set_err;
+    }
 
-    int gpio_dir0_value = 0;
-    int gpio_dir1_or_brake_value = 0;
+    const motor_t *motor = &motor_driver->params->motors[motor_id];
 
     motor_direction_t direction = (pwm_duty_cycle < 0) ? MOTOR_CCW : MOTOR_CW;
-
-    direction = direction ^ dev->gpio_dir_reverse;
-
-    /* Two direction GPIO, handling brake */
-    if (motor_driver_conf->mode == MOTOR_DRIVER_2_DIRS) {
-        if (!gpio_is_valid(dev->gpio_dir0) || \
-            !gpio_is_valid(dev->gpio_dir1_or_brake)) {
-            err = ENODEV;
-            goto motor_set_err;
-        }
-        switch (direction) {
-            case MOTOR_CW:
-            case MOTOR_CCW:
-                /* Direction */
-                gpio_dir0_value = direction;
-                gpio_dir1_or_brake_value = direction ^ 0x1;
-                break;
-            default:
-                pwm_duty_cycle = 0;
-                break;
-        }
-    }
-    /* Single direction GPIO */
-    else if (motor_driver_conf->mode == MOTOR_DRIVER_1_DIR) {
-        if (!gpio_is_valid(dev->gpio_dir0)) {
-            err = ENODEV;
-            goto motor_set_err;
-        }
-        switch (direction) {
-            case MOTOR_CW:
-            case MOTOR_CCW:
-                /* Direction */
-                gpio_dir0_value = direction;
-                break;
-            default:
-                pwm_duty_cycle = 0;
-                break;
-        }
-    }
-    /* Single direction GPIO and brake GPIO */
-    else if (motor_driver_conf->mode == MOTOR_DRIVER_1_DIR_BRAKE) {
-        if (!gpio_is_valid(dev->gpio_dir0) || \
-            !gpio_is_valid(dev->gpio_dir1_or_brake)) {
-            err = ENODEV;
-            goto motor_set_err;
-        }
-        switch (direction) {
-            case MOTOR_CW:
-            case MOTOR_CCW:
-                /* Direction */
-                gpio_dir0_value = direction;
-                /* No brake */
-                gpio_dir1_or_brake_value = dev->gpio_brake_invert;
-                break;
-            default:
-                pwm_duty_cycle = 0;
-                break;
-        }
-    }
-    else {
-        err = EINVAL;
-        goto motor_set_err;
+    direction = direction ^ motor->gpio_dir_reverse;
+
+    switch (direction) {
+        case MOTOR_CW:
+        case MOTOR_CCW:
+            break;
+        default:
+            pwm_duty_cycle = 0;
+            break;
     }
 
     /* Absolute value of pwm_duty_cycle */
     int32_t pwm_duty_cycle_abs = pwm_duty_cycle;
     pwm_duty_cycle_abs *= (pwm_duty_cycle < 0) ? -1 : 1;
 
-    unsigned irqstate = irq_disable();
-    gpio_write(dev->gpio_dir0, gpio_dir0_value);
-    gpio_write(dev->gpio_dir1_or_brake, gpio_dir1_or_brake_value);
-    pwm_set(motor_driver_conf->pwm_dev, dev->pwm_channel, \
+    /* Critical section */
+    int state = irq_disable();
+
+    /* Set direction */
+    if (motor_driver->motor_set_cb) {
+        motor_driver->motor_set_cb(motor,
+                                   direction);
+    }
+
+    /* Apply PWM duty cycle */
+    pwm_set(motor_driver->params->pwm_dev, motor->pwm_channel, \
             (uint16_t)pwm_duty_cycle_abs);
-    irq_restore(irqstate);
 
-    motor_driver_cb_t cb = motor_driver_conf->cb;
-    if (cb) {
-        cb(motor_driver, motor_id, pwm_duty_cycle);
+    /* Remove brake */
+    if (motor_driver->motor_brake_cb) {
+        motor_driver->motor_brake_cb(motor, !motor_driver->params->brake_level);
+    }
+
+    /* End of critical section */
+    irq_restore(state);
+
+    if (motor_driver->params->motor_set_post_cb) {
+        motor_driver->params->motor_set_post_cb(motor_driver, motor_id, pwm_duty_cycle);
     }
 
     return 0;
@@ -186,58 +200,49 @@ motor_set_err:
     return -err;
 }
 
-int motor_brake(const motor_driver_t motor_driver, uint8_t motor_id)
+static void _motor_brake_two_dirs(const motor_t *motor,
+                           motor_driver_brake_level_t brake)
 {
-    int err = 0;
+    if ((gpio_is_valid(motor->gpio_dir0))
+       && (gpio_is_valid(motor->gpio_dir1_or_brake))) {
+        gpio_write(motor->gpio_dir0, brake);
+        gpio_write(motor->gpio_dir1_or_brake, brake);
+    }
+}
 
-    assert(motor_driver < MOTOR_DRIVER_NUMOF);
+static void _motor_brake_one_dir_brake(const motor_t *motor,
+                                motor_driver_brake_level_t brake)
+{
+    if (gpio_is_valid(motor->gpio_dir1_or_brake)) {
+        gpio_write(motor->gpio_dir1_or_brake, brake);
+    }
+}
 
-    const motor_driver_config_t *motor_driver_conf =
-        &motor_driver_config[motor_driver];
+int motor_brake(const motor_driver_t *motor_driver, uint8_t motor_id)
+{
+    int err = 0;
 
-    assert(motor_id < motor_driver_conf->nb_motors);
+    if (motor_id >= motor_driver->params->nb_motors) {
+        err = EINVAL;
+        LOG_ERROR("Motor ID %u greater than number of motors %u\n",
+                  motor_id, motor_driver->params->nb_motors);
+        goto motor_brake_err;
+    }
 
-    const motor_t *dev = &motor_driver_conf->motors[motor_id];
+    const motor_t *motor = &motor_driver->params->motors[motor_id];
 
-    int gpio_dir0_value = 0;
-    int gpio_dir1_or_brake_value = 0;
+    /* Critical section */
+    int state = irq_disable();
 
-    /* Two direction GPIO, handling brake */
-    if (motor_driver_conf->mode == MOTOR_DRIVER_2_DIRS) {
-        if (!gpio_is_valid(dev->gpio_dir0) || \
-            !gpio_is_valid(dev->gpio_dir1_or_brake)) {
-            err = ENODEV;
-            goto motor_brake_err;
-        }
-        /* Brake */
-        gpio_dir0_value =
-            motor_driver_conf->mode_brake;
-        gpio_dir1_or_brake_value =
-            motor_driver_conf->mode_brake;
-    }
-    /* Single direction GPIO */
-    else if (motor_driver_conf->mode == MOTOR_DRIVER_1_DIR) {
-        /* Nothing to do here */
-    }
-    /* Single direction GPIO and brake GPIO */
-    else if (motor_driver_conf->mode == MOTOR_DRIVER_1_DIR_BRAKE) {
-        if (!gpio_is_valid(dev->gpio_dir1_or_brake)) {
-            err = ENODEV;
-            goto motor_brake_err;
-        }
-        /* Brake */
-        gpio_dir1_or_brake_value = 1 ^ dev->gpio_brake_invert;
-    }
-    else {
-        err = EINVAL;
-        goto motor_brake_err;
+    /* Apply brake */
+    if (motor_driver->motor_brake_cb) {
+        motor_driver->motor_brake_cb(motor, motor_driver->params->brake_level);
     }
 
-    unsigned irqstate = irq_disable();
-    gpio_write(dev->gpio_dir0, gpio_dir0_value);
-    gpio_write(dev->gpio_dir1_or_brake, gpio_dir1_or_brake_value);
-    pwm_set(motor_driver_conf->pwm_dev, dev->pwm_channel, 0);
-    irq_restore(irqstate);
+    /* Reset PWM duty cycle */
+    pwm_set(motor_driver->params->pwm_dev, motor->pwm_channel, 0);
+
+    irq_restore(state);
 
     return 0;
 
@@ -245,34 +250,36 @@ motor_brake_err:
     return -err;
 }
 
-void motor_enable(const motor_driver_t motor_driver, uint8_t motor_id)
+void motor_enable(const motor_driver_t *motor_driver, uint8_t motor_id)
 {
-    assert(motor_driver < MOTOR_DRIVER_NUMOF);
-
-    const motor_driver_config_t *motor_driver_conf =
-        &motor_driver_config[motor_driver];
-
-    assert(motor_id < motor_driver_conf->nb_motors);
-
-    const motor_t *dev = &motor_driver_conf->motors[motor_id];
+    if (motor_id >= motor_driver->params->nb_motors) {
+        LOG_ERROR("Motor ID greater than number of motors\n");
+        return;
+    }
 
-    assert(gpio_is_valid(dev->gpio_enable));
+    const motor_t *motor = &motor_driver->params->motors[motor_id];
 
-    gpio_write(dev->gpio_enable, 1 ^ dev->gpio_enable_invert);
+    if (gpio_is_valid(motor->gpio_enable)) {
+        gpio_write(motor->gpio_enable, motor_driver->params->enable_level);
+    }
+    else {
+        LOG_WARNING("Enable GPIO is not valid for motor %u, skipping enable\n", motor_id);
+    }
 }
 
-void motor_disable(const motor_driver_t motor_driver, uint8_t motor_id)
+void motor_disable(const motor_driver_t *motor_driver, uint8_t motor_id)
 {
-    assert(motor_driver < MOTOR_DRIVER_NUMOF);
-
-    const motor_driver_config_t *motor_driver_conf =
-        &motor_driver_config[motor_driver];
-
-    assert(motor_id < motor_driver_conf->nb_motors);
-
-    const motor_t *dev = &motor_driver_conf->motors[motor_id];
+    if (motor_id >= motor_driver->params->nb_motors) {
+        LOG_ERROR("Motor ID greater than number of motors\n");
+        return;
+    }
 
-    assert(gpio_is_valid(dev->gpio_enable));
+    const motor_t *motor = &motor_driver->params->motors[motor_id];
 
-    gpio_write(dev->gpio_enable, dev->gpio_enable_invert);
+    if (gpio_is_valid(motor->gpio_enable)) {
+        gpio_write(motor->gpio_enable, !motor_driver->params->enable_level);
+    }
+    else {
+        LOG_WARNING("Enable GPIO is not valid for motor %u, skipping disable\n", motor_id);
+    }
 }
-- 
2.37.0

